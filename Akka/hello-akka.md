# akka 

* 도움되는 참고할만한 글
 - https://k9e4h.tistory.com/347
 - https://ckddn9496.tistory.com/154
 - 스칼라 문법요약 https://jdm.kr/blog/85
 - ActiveObject와 Actor with Akka(하마가 okky에 쓴 글)  https://okky.kr/article/279263

* 액터의 개념 이해
- 액터는 생성, 송신, 상태변화, 감독 / create, send, become, supervise라는 네가지 핵심연산만을 제공하는 경량 프로세스.
- 액터는 액터 모델을 이루는 기본 단위
- 모든 연산은 비동기적
- 모든 컴포넌트는 액터

* 액터의 부가 설명
- 액터는 설정, 메시지브로커 설치라는 부가비용이 들지 않는 메시지큐와 비슷
- 프로그래밍 가능한 메시지큐를 아주 작은 크기로 줄인 것
- 각 액터는 메시지를 받기 전까지는 아무런 일도 수행하지 X
- 액터가 받는 메세지는 생성된 다음에는 변경될 수 X (immutable 불변)
- 액터는 한 번에 하나의 메시지를 받을 수 있으며, 받을 때마다 어떤 동작을 수행
- 액터가 수행하는 모든 것은 비동기적으로 실행

* 액터의 핵심연산
송신 : 액터가 다른 액터와 의사소통하는 방법은 오직 메세지 보내기. fire and forget. 메시지의 순서 유지. 내부 상태에 대한 외부접근 X
생성 : 액터는 다른 액터를 생성 가능 -> 계층구조 만들어짐
상태변화 : 상태 기계(state machine)은 어떤 시스템이 특정 상태에 있을 때만 특정 동작을 수행하도록 보장하고 싶을 때 사용
감독 : 액터는 자신이 만든 다른 액터를 감독.

- tell ( ! ) : 보내고 잊기(fire-and-forget). 비동기로 메시지 보내고 즉시 리턴
- ask ( ? ) : 동기로 메시지 보내고 응답에 대한 future 반환
            ask는 타임아웃에 대한 처리와 Promise를 원격의 ActorRef로 브리지 해야 하는 추가적인 처리가 필요 --> 성능저하 --> 필요할 때만 사용 권장


* 액터의 메시지 회신
- 메시지에 회신을 하려면 sender() ! replyMsg와 같이 sender()가 반환한 ActorRef에 응답 메시지를 보냄
- 나중에 응답하기 위해서 ActorRef를 저장
- 발신자가 없는 메시지의 경우에는 dead-letter가 디폴트 발신자로 설정됨

* 액터의 주요 개념
- 액터시스템(ActorSystem)
  : 아카는 ActorSystem을 제공하여 최상위 액터를 만들 수 있도록 한다.
   애플리케이션의 모든 액터 위에 최상위 액터를 오직 하나만 만드는 것이 일반적인 패턴
   모든 액터들은 액터시스템의 context 내에서 동작
- 액터참조(ActorRef)
  : ActorSystem이 반환하는 액터의 주소 / ActorSystem은 액터객체를 반환하는 게 아니라 주소를 반환
    액터에게 메시지를 보내려면 ActorRef를 사용해야 함
- 액터경로(ActorPath)
  : 액터 시스템에서 액터를 찾을 때 사용하는 개념.
    액터의 계층 구조는 Url의 경로 구조와 비슷
    모든 액터는 이름이 있는데, 이름은 같은 계층 내에서 유일해야 함
- 액터참조 vs 액터경로
  : 액터 참조는 액터가 실제 있어야 만들어진다. 반면 패스는 실제 액터가 없어도 만들 수 있다.
  A 액터를 만들고 종료시키고 B 액터를 만들었을때, 동일한 액터패스를 가질 수 있다. 그냥 이름이니깐.
  하지만 액터 참조는 그대로 사용할 수 없다. 액터참조는 대응되는 액터의 라이프 사이클과 함께 한다.
- 디스패처(dispatcher)
  : 우편함에 있는 메세지를 액터에게 푸시 -> 액터가 깨어남

* 액터의 감시/감독
감시 - 누구나 가능(단, 액터의 ActorRef를 알아야 함)
감독 - 부모 액터만 자식 액터에 대해서 가능


* 액터의 모범사례
1) 액터는 이벤트 중심 방식으로 이벤트를 처리하고 응답(또는 추가적인 요청)을 만들어내야 한다.
2) 액터들이 가변 객체를 교환해서는 안 된다 (그렇지 않으면 캡슐화가 무너지고 동시성 문제가 다시 원점)
  // 아직 스칼라에서 불변성을 강제할 수 있는 문법적 방법이 없으므로, 관례를 따르는 것이 중요
  // String, Int, Boolean과 같은 원시 자료형은 언제나 불변
3) 액터는 행동방식과 상태를 담아두기 위해 만들어지므로, 행동방식을 메시지에 담아서 보내면 안 된다.
   (스칼라의 클로저를 메시지에 담아 보내면 X)
4) 최상위 액터는 최소한으로 만들어야 함.(에러 커너르이 가장 깊은 부분)


* 액터를 멈추는 방법 4가지 // 레퍼런스가 없다고 자동으로 소멸하지 않고, 명시적으로 개발자가 종료시켜야 함
  0. context.stop(self) : 멈추게 하자. (우편함의 메시지 날라감)
  1. actor ! Kill : 멈추진 말고 단순 재시작하게 하자. (우편함의 메세지 살아있음)
  2. actor ! PoisonPill : 어떤 메세지까지는 처리하고 중단하게 하자. (PoisonPill 메세지 전까지 모두 처리)
  3. watch : 다른 액터가 끝날때까지 기다리게 하자. (액터 내부에서 기다림)
  4. gracefulStop : 다른 액터가 끝날때까지 기다리게 하자.(액터 외부에서 기다림)


* Future / 액터의 오류
- 자바의 블로킹과 비슷한 개념
- context.watch를 하면 acor에서 종료되는 메세지를 전달받음
- onComplete, await
- actor에서 exception이 발생하면 recover에서 값 복구 -> timeout이 지나면 recover에서 복구한 값을 future에서 가져감
- 오류가 나면 하위 계층까지 다 죽었다가 restart되므로 오류 가능성이 가장 높은 애를 하위 계층으로 두는 것이 바람직
- unbecome - state를 복구시킴

* 액터의 재시작
액터가 오류가 나는 경우
- 수신한 특정 메세지에 대한 시스템적(프로그래밍 상) 오류
- 메세지를 처리하는 동안 사용한 외부 리소스의 실패
- 액터 내부 상태의 오염



* onComplete 핸들러



* 액터의 계층구조

- /: 루트 가디언
  루트 가디언의 목적은 어떤 형태든 예외가 발생하면 액터를 종료하는 것
  각각의 실질 액터는 하나의 수퍼바이저를 가지기 때문에 루트 가디언의 수퍼바이저는 실제의 액터가 될 수 없습니다.
  문제가 발생했다는 보고를 한 자식을 실제로 중지하는 가상의 ActorRef이며 루트 가디언이 완전히 종료되는 즉시 액터시스템의 isTerminated 상태를 true로 설정

- /system: 시스템 가디언
  로그를 기록하는 기능을 액터로 구현하더라도, 모든 일반 액터들이 순차적으로 종료되는 동안 남아있는 활동들을 로그에 남길 수 있도록 하는 특별한 가디언
  시스템 가디언은 유저 가디언을 감시하다가 Terminated 메시지를 수신하면 종료하게 되어있음
  최상위 시스템 액터에 대해서는 ActorInitializationException과 ActorKilledException을 받으면 중지시킴(stop)
  --> 위 두 가지를 제외한 모든 예외에 대해서는 재시작(restart)

- /user: 가디언 액터
  system.actorOf()를 사용해서 만든 액터는 모두 이 액터의 자식이 됨
  --> 따라서 이 가디언이 종료되면 시스템에 있는 모든 일반 액터들도 같이 종료됨
  최상위 일반 액터들은 이 가디언의 정책에 따라 감독을 받음




#### akka의 메시지 송신 연산

* ! (tell) : 
* ? (ask) : 