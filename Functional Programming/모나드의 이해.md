

# 배경 설명

## Monad는 언제 쓰는가

- 비동기 연산 처리 --- Promise 클래스 (모나드의 일종)
- Null 처리         --- Optional 클래스 (모나드의 일종)

## Monad의 설명
- 값을 담는 컨테이너의 일종
- Functor를 기반으로 구현되었음
- flatMap() 메소드를 제공
- Monad Laws를 만족시키는 구현체를 말함


# 필요한 배경 지식

### Functor 펑터

어떤 값을 캡슐화하는 타입 인자를 가지는 자료구조

먼저 구조를 살펴보면, 펑터는 아래의 API를 가지는 컨테이너를 말한다.

import java.util.function.Function;
interface Functor<T> {
    <R> Functor<R> map(Function<T,R> f);
}

- 펑터가 제공하는 유일한 연산은 map 메소드
- 타입 인자 <T>를 가진다.
- 인자로 전달하는 함수 f는  <T>타입 값을 받아 <R> 타입 값을 반환
- Functor는 map 함수를 거쳐 <R> 타입의 Functor를 반환

인자로 전달하는 함수는 컨테이너 혹은 박스에 담긴 값을 변형하고, 
map()




인자로 전달하는 함수는 컨테이너 혹은 박스에 담긴 값을 변형하고, map은 그 결과를 다시 새로운 펑터로 포장한다. 주의해서 읽어야 한다. Functor<T>는 항상 불변형의 컨테이너이다. 따라서 map은 원래의 객체를 절대 변경하지 않는다. 대신 인자 함수로 변형한 결과값을 완전히 새로운 펑터 객체에 감싸서 반환한다.(결과 타입 R은 다른 타입일 수도 있다.) 추가로 펑터는 identity 함수가 전달되었을 때, 즉 map(x -> x)가 호출되었을 때 어떤 다른 동작도 취해서는 안된다. (역주: side-effect가 없음을 말한다) 이런 패턴의 경우 항상 같은 펑터나 같은 인스턴스를 반환해야 한다.


### Functor를 사용하는 이유

1. Functor를 이용하면, 일반적으로 모델링할 수 없는 상황을 모델링할 수 있음
ex) 값이 없는 케이스
ex) 값이 미래에 준비될 것으로 예상되는 케이스

2. 함수들을 합성할 수 있음

### 컨테이너
같은 타입의 여러 객체를 저장하는 일종의 집합


자바를 예시로, java.util 라이브러리가 제공하는 List, Set, Queue, Map 등이 바로 컨테이너 클래스이다.






### 비동기 연산 처리
자바스크립트의 경우, 콜백함수를 넣어서 비동기처리를 하기도 하지만 콜백지옥에 빠지게 되기도 한다.

이런걸 처리하기 위해 Promise를 사용하기도 하는데, 이게 바로 모나드의 일종임



## Promise 프로미스



## Haskel 하스켈
모나드와 종종 함께 언급되는 하스켈 언어는 