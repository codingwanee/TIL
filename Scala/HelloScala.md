
# 스칼라

## 스칼라 소개 및 장점

* 2004년 마틴 오티스가 창시한 언어로, scalable language에서 이름이 비롯됨
* 정적 타입 / 자바보다 더 강력한 타입 추론을 제공
* OOP 완벽 지원 / 스칼라에서는 모든 것이 객체(원시자료형도). 혼합 합성을 사용하는 trait 지원
* 함수형 프로그래밍 / 
* 간결한 구문 / 도메인 특화 언어(DSL) 또는 API 제공
* 규모 확장성 / trait, 추상타입 멤버, 제네릭스, 내포 클래스, 자기타입 지정 등의 메커니즘


## 스칼라 관련 기초단어 익히기

* SBT: Scala Build Tool는 사실상 산업 표준 스칼라 빌드 도구. 자바-스프링의 Maven, Gradle과 비슷한 개념이다.
* Scala REPL: Read-Eval-Print-Loop는 컴파일 없이 콘솔에서 코드를 입력하고 출력 결과를 확인할 수 있는 환경이다. 진짜로 컴파일을 하지 않는 게 아니라, 개발자가 명시할 필요 없다는 뜻이다.



## 스칼라 활용법 기본

#### 클래스

* class 키워드로 시작한다.
* 전체 본문은 중괄호{...} 사이에 위치 (클래스 본문 = 클래스 주 생성자)
* 생성자에 매개변수가 필요한 경우 클래스명 뒤 ( )에 매개변수 목록 추가

```Scala

```


##### 케이스 클래스 case class

스칼라는 **케이스 클래스**라는 것을 제공한다.
요약하면 아래 네 가지 특징을 갖는다.

* 기본적으로 불변
    * 파라미터의 목록에 val 접두사를 붙인다.
* 패턴 매칭을 통해 분해가능
* 레퍼런스가 아닌 구조적인 동등성으로 비교됨
* apply와 unapply가 있는 동반 객체를 자동으로 생성
* 초기화와 운영이 간결함
    * 컴파일러가 자동으로 케이스 클래스와 동일한 이름의 팩토리 메소드를 추가한다. 따라서 new MyClass(3.0) 대신에 MyClass(3.0)이 가능하다.
    * 인자들의 getter methods들이 자동으로 추가된다.
    * hashCode와 equals, toString, copy 메소드들이 자동으로 추가된다.

```Scala
    case class MyClass(x: String, y: Int) {
        // ...
    }
```


#### object

* 스칼라의 싱글턴 객체
* 스칼라가 static을 지원하지 않는 이유는 스칼라는 모든 것이 객체여야 한다는 목표 때문이다. 자바의 static 메서드나 필드는 특정 타입의 실제 인스턴스와 연관이 없는 반면, 스칼라의 object는 실제로 어떤 타입의 유일한 인스턴스다.

```Scala

```

#### 동반 클래스, 동반 객체

* 스칼라는 한 파일 내에 이름이 동일한 클래스와 객체가 존재할 시, 이 둘을 묶어 각각 동반 클래스, 동반 객체라고 부른다.
* 일반 클래스의 경우 직접 개발자가 정의해서 이용할 수 있고, 케이스 클래스의 경우는 컴파일러가 자동으로 동반 객체를 만들어낸다.
* 동반 객체에는 메서드를 추가할 수 있다. 또한, 자동으로 추가되는 메서드도 몇 가지 있는데 그 중 하나가 apply 메소드이다. apply 메소드는 동반 클래스의 생성자와 같은 인자를 받는다. 객체 뒤에 인자 목록을 덧붙이면 스칼라는 그 객체의 apply를 호출하기 위해 찾는다. 즉, 아래 두 줄은 동등한 식이다.

```Scala
    val p1 = MyClass.apply(1, 2)
    val p2 = MyClass(1, 2)
```

#### 메소드

  ```Scala
    def myFunction(str: String*): Seq[String] = ...
    // String 뒤에 *가 붙은  것은 가변길이 인자 목록을 뜻함
    // (즉 원하는 만큼 문자열을 콤마(,)로 분리해 인자로 넘길 수 있음)
  ```

* 스칼라는 return 키워드를 되도록 명시하지 않고 메소드 가장 마지막 값이 return 값임을 추론한다.
* 한편, 재귀함수의 반환 타입은 반드시 지정해야 한다. 스칼라는 기본적으로 지역 타입 추론 알고리즘을 통해 함수 본문 전체를 보고 타입을 추론하는데, 재귀함수의 반환타입은 실행영역이 본문을 벗어나기 때문이다.
* 아무 값도 반환하지 않는 경우, 자바에서는 void라고 표현하지만 스칼라에서는 **Unit**이라고 표현한다.
* 또한 스칼라는 문장 끝에 세미콜론(;)도 생략하는 것을 권장하고 있다.


#### 변수

* var : 변수
* val : 상수. 변경 불가능한 값
* 스칼라에서 변수란 **값 객체**라고 이해하는 것이 더 편하다. 스칼라도 자바와 마찬가지로 대부분의 변수가 힙에 할당된 객체를 참조한다.
* 관례적으로 둘 다 변수라고 부르며 상수를 **변경 불가능한 변수**라고 부르기도 하지만, 나는 변수와 상수라고 구분해서 표현하겠다.
* 여기서 **불변**의 대상은 값이 아닌 객체이다. 즉, val로 선언한 객체는 객체 자체를 변경할 수는 없지만 값을 변경할 수는 있다.
* var나 val 키워드는 어떤 참조가 다른 객체를 참조하도록 변경될 수 있는지 여부만 지정한다. 참조가 가리키는 대상 객체의 내부 상태를 변경 가능한지 여부는 지정하지 않는다.

```Scala
    class Person(val name: String, var age: Int) // 클래스 선언. 생성자 매개변수 name은 상수, age는 변수

    val p = new Person("Wanee", 21) // 21살 와니 객체를 생성. 영원히 21살이고 싶다.

    p.name = "Other name" // 변경 불가능. val로 선언되었기 때문

    p.age = 25 // 변경 가능. var로 선언되었기 때문

    // 객체 p가 참조하는 주소가 그대로기 때문에 객체 안의 var로 선언된 값은 변경 가능하다.
```
* 위의 코드처럼 클래스에 매개변수를 넣으면 private 변수로 생성된다.
* 이 경우 val로 생성할 경우 getter를, var로 생성할 경우 getter, setter 메소드를 자동으로 생성한다.


#### 주석

* 한줄주석 //  여러줄 주석 /* */


#### 연산자

* 대부분의 '연산자'는 실제로는 메소드다. (반면 씨에서는 메소드가 실제 명령어로 매핑됨)
* 자바의 원시타입 primitive type은 스칼라에서는 일반적인 객체다.

```Scala
    1 + 2
    1.+(2)
```
* 따라서 위 코드 두 줄은 같은 의미이다.

##### 연산자 우선순위

1. 모든 글자
2. |
3. ^
4. &
5. < >
6. = !
7. :
8. + =
9. * / %
10. 다른 모든 특수 문자



## akka - actor

* **akka**는 스칼라가 강력하고 튼튼한 동시성 애플리케이션을 제공할 수 있도록 하는 API이다. (http://akka.io 참고)
* akka는 actor라는 모델을 기반으로 하는데, **actor**는 서로 아무런 상태 정보를 공유하지 않는 독립적인 소프트웨어 요소이다. 상태를 공유하지 않는 대신, 액터들은 메시지 교환을 통해 서로 의사소통한다.
* akka-actor에 관한 더 자세한 내용은 [여기에] 따로 정리해놓았다.

## 스칼라의 불변성



