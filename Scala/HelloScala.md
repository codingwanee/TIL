
# 스칼라

## 스칼라 소개 및 장점

* 2004년 마틴 오티스가 창시한 언어로, scalable language에서 이름이 비롯됨
* 정적 타입 / 자바보다 더 강력한 타입 추론을 제공
* OOP 완벽 지원 / 스칼라에서는 모든 것이 객체(원시자료형도). 혼합 합성을 사용하는 trait 지원
* 함수형 프로그래밍 / 
* 간결한 구문 / 도메인 특화 언어(DSL) 또는 API 제공
* 규모 확장성 / trait, 추상타입 멤버, 제네릭스, 내포 클래스, 자기타입 지정 등의 메커니즘


## 스칼라 관련 기초단어 익히기

* SBT: Scala Build Tool는 사실상 산업 표준 스칼라 빌드 도구. 자바-스프링의 Maven, Gradle과 비슷한 개념이다.
* Scala REPL: Read-Eval-Print-Loop는 컴파일 없이 콘솔에서 코드를 입력하고 출력 결과를 확인할 수 있는 환경이다. 진짜로 컴파일을 하지 않는 게 아니라, 개발자가 명시할 필요 없다는 뜻이다.



## 스칼라 활용법 기본

#### 정의
* var : 필드 정의 / 변수
* val : 필드 정의 / 상수
* def : 메소드 정의


#### 스칼라의 필드
* 디폴트는 전체공개 (자바와 다름)
* 필드를 비공개로 만들고 싶으면 private 또는 protected 키워드 사용
* private : 클래스나 객체 내부에서만 접근가능
* protected : 클래스의 하위클래스에서만 접근가능


#### 클래스
* class 키워드로 시작
* 전체 본문은 중괄호{...} 사이에 위치 (클래스 본문 = 클래스 주 생성자)
* 생성자에 매개변수가 필요한 경우 클래스명 뒤 ( )에 매개변수 목록 추가
* 한줄 만으로도 클래스를 생성 가능 ex) class Person(var name: String, var age: Int) // name, age는 인자가 아니라 생성자


##### 케이스 클래스 case class
* 기본적으로 불변
    * 파라미터의 목록에 val 접두사를 붙인다.
* 패턴 매칭을 통해 분해가능
* 레퍼런스가 아닌 구조적인 동등성으로 비교됨
* apply와 unapply가 있는 동반 객체를 자동으로 생성
* 초기화와 운영이 간결함
    * 컴파일러가 자동으로 케이스 클래스와 동일한 이름의 팩토리 메소드를 추가한다. 따라서 new MyClass(3.0) 대신에 MyClass(3.0)이 가능하다.
    * 인자들의 getter methods들이 자동으로 추가된다.
    * hashCode와 equals, toString, copy 메소드들이 자동으로 추가된다.
* 특징
    - 유용한 행사코드를 자동으로 생성 가능 즉, toString, equals, hashCode 메소드 자동생성
    - 생성자 파라미터에 getter, setter 속성 부여
    - 인스턴스로 만드는 데 new 연산자 필요 X
    - match/case문에서 편리하게 이용

```Scala
    case class MyClass(x: String, y: Int) {
        // ...
    }
```

#### trait
* 자바의 인터페이스 또는 추상클래스와 비슷한 개념
    - 인터페이스처럼 다중상속 가능
    - 추상클래스처럼 구현부 선언 가능
    - 스칼라에서 abstract class를 사용하는 경우는
        1) constructor argument를 요구하는 base class를 만드는 경우
        2) java에서 이용할 코드인 경우


## object

* 스칼라의 싱글턴 객체
* 스칼라가 static을 지원하지 않는 이유는 스칼라는 모든 것이 객체여야 한다는 목표 때문이다. 자바의 static 메서드나 필드는 특정 타입의 실제 인스턴스와 연관이 없는 반면, 스칼라의 object는 실제로 어떤 타입의 유일한 인스턴스다.


## 동반 클래스, 동반 객체

* 스칼라는 한 파일 내에 이름이 동일한 클래스와 객체가 존재할 시, 이 둘을 묶어 각각 동반 클래스, 동반 객체라고 부른다.
* 일반 클래스의 경우 직접 개발자가 정의해서 이용할 수 있고, 케이스 클래스의 경우는 컴파일러가 자동으로 동반 객체를 만들어낸다.
* 동반 객체에는 메서드를 추가할 수 있다. 또한, 자동으로 추가되는 메서드도 몇 가지 있는데 그 중 하나가 apply 메소드이다. apply 메소드는 동반 클래스의 생성자와 같은 인자를 받는다. 객체 뒤에 인자 목록을 덧붙이면 스칼라는 그 객체의 apply를 호출하기 위해 찾는다. 즉, 아래 두 줄은 동등한 식이다.

```Scala
    val p1 = MyClass.apply(1, 2)
    val p2 = MyClass(1, 2)
```


## 메소드

#### 선언방식
- 일반적인 메소드 선언방식
    def add(x:Int, y:Int):Int = {
        return x + y
    }
- 스칼라의 선언방식
    ```Scala
        def myFunction(str: String*): Seq[String] = ...
        // String 뒤에 *가 붙은  것은 가변길이 인자 목록을 뜻함
        // (즉 원하는 만큼 문자열을 콤마(,)로 분리해 인자로 넘길 수 있음)
    ```
    - 스칼라에서는 보통 return을 명시적으로 사용하지 않음 (메소드가 한 값을 계산하는 표현식처럼 작성 권장)
    - 이 경우 return을 적어주지 않아도 마지막 값이 return값
        def addWithoutReturn(x:Int, y:Int) = { // x + y는 int이므로 return타입은 Int로 결정
            x + y // return을 적어주지 않아도 마지막 값이 return 값
        }

* 스칼라는 return 키워드를 되도록 명시하지 않고 메소드 가장 마지막 값이 return 값임을 추론한다.(즉 return 을 명시하지 않아도 마지막 값이 return값)
* 한편, 재귀함수의 반환 타입은 반드시 지정해야 한다. 스칼라는 기본적으로 지역 타입 추론 알고리즘을 통해 함수 본문 전체를 보고 타입을 추론하는데, 재귀함수의 반환타입은 실행영역이 본문을 벗어나기 때문이다.
* 아무 값도 반환하지 않는 경우, 자바에서는 void라고 표현하지만 스칼라에서는 **Unit**이라고 표현한다.
* 또한 스칼라는 문장 끝에 세미콜론(;)도 생략하는 것을 권장하고 있다.


#### 다양한 메소드 형태
* {} 중괄호를 생략하는 경우
    * 메소드가 오직 하나의 표현식으로만 계산하는 경우
* = 을 생략하는 경우
    - Unit을 생략하고 =을 없애서 {} 로 메소드를 나타내면 프로시저처럼 작성됨 // 이 경우 리턴이 무조건 Unit
    - Unit 타입이란? : 자바의 void // 메소드의 결과타입이 Unit인 경우는 부수 효과를 위해 사용한다는 뜻


## 변수
* var : 변수
* val : 상수. 변경 불가능한 값
* 스칼라에서 변수란 **값 객체**라고 이해하는 것이 더 편하다. 스칼라도 자바와 마찬가지로 대부분의 변수가 힙에 할당된 객체를 참조한다.
* 관례적으로 둘 다 변수라고 부르며 상수를 **변경 불가능한 변수**라고 부르기도 하지만, 나는 변수와 상수라고 구분해서 표현하겠다.
* 여기서 **불변**의 대상은 값이 아닌 객체이다. 즉, val로 선언한 객체는 객체 자체를 변경할 수는 없지만 값을 변경할 수는 있다.
* var나 val 키워드는 어떤 참조가 다른 객체를 참조하도록 변경될 수 있는지 여부만 지정한다. 참조가 가리키는 대상 객체의 내부 상태를 변경 가능한지 여부는 지정하지 않는다.

```Scala
    class Person(val name: String, var age: Int) // 클래스 선언. 생성자 매개변수 name은 상수, age는 변수

    val p = new Person("Wanee", 21) // 21살 와니 객체를 생성. 영원히 21살이고 싶다.

    p.name = "Other name" // 변경 불가능. val로 선언되었기 때문

    p.age = 25 // 변경 가능. var로 선언되었기 때문

    // 객체 p가 참조하는 주소가 그대로기 때문에 객체 안의 var로 선언된 값은 변경 가능하다.
```
* 위의 코드처럼 클래스에 매개변수를 넣으면 private 변수로 생성된다.
* 이 경우 val로 생성할 경우 getter를, var로 생성할 경우 getter, setter 메소드를 자동으로 생성한다.


## 주석
* 한줄주석 //  여러줄 주석 /* */


## 연산자
* 대부분의 '연산자'는 실제로는 메소드다. (반면 씨에서는 메소드가 실제 명령어로 매핑됨)
* 자바의 원시타입 primitive type은 스칼라에서는 일반적인 객체다.

```Scala
    1 + 2
    1.+(2)
```
* 따라서 위 코드 두 줄은 같은 의미이다.



##### 연산자 우선순위
1. 모든 글자
2. |
3. ^
4. &
5. < >
6. = !
7. :
8. + =
9. * / %
10. 다른 모든 특수 문자



## 스칼라의 객체
* 동일객체 판단 방법 (https://hamait.tistory.com/575?category=79134)
- equals, ==, eq 연산자 이용 --> 모두 동일주소 비교
- 자바에서는 equals, == 각기 오버라이딩 해서 쓸 수 있지만, 스칼라는 equals를 오버라이드하면 ==의 의미도 재정의

* 스칼라의 연산자
- 스칼라는 모든 연산자가 메소드 --> * > + 와 같이 연산자 간의 우선순위를 설정하는데
  이와 같은 표현 방식은 연산자 표기방식(Operator notation) 또는 infix 표기방식이라고 합니다.
  ex) 1 + 2 ===> (1).+(2) 와 같다
- 스칼라의 원시 타입은 스칼라에서 객체로 취급되지만, 컴파일 이후에는 성능을 위해 자바의 원시 타입을 이용합니다.(자바의 원시 타입을 쓸 수 있는 경우에 만요)

* 암시적 변환 implicit conversion
- 스칼라 기본타입을 래퍼 클래스로 변환하는 것

* 싱글톤 객체
- '스칼라는 정적 멤버가 없다' - 스칼라와 자바의 가장 큰 차이점중에 하나  // * 멤버 - 메서드, 값, 변수, 타입, 객체, 트레잇, 클래스 등
- 대신 object 키워드를 가지고 전용으로 사용할 수 있는 싱글톤 객체를 제공
- 싱글톤 객체 정의는 타입을 지정하지 않음.
- 싱글톤은 슈퍼클래스를 확장하거나, 트레이트를 믹스인 할 수 있다.
- 클래스와 싱글톤 객체의 한 가지 차이는 싱글톤 객체는 파라미터를 받을 수 없고 클래스는 받을 수 있다는 점이다.
- 동반 클래스가 없는 싱글톤 객체를 독립 객체라 한다.
- 컴파일러는 싱글톤 객체의 이름 뒤에 달러기호($)를 붙여서 클래스를 만든다.
  ex) SampleSingleton 라는 싱글톤 객체가 있다고 한다면 SampleSingleton$이란 이름으로 클래스를 만들어냄

#### 동반객체 companion object
- 같은 파일 내에 있는 클래스와 object의 이름을 동일하게 만들면 '동반객체'가 된다.
- 클래스와 동반객체는 상대방의 비공개 멤버에 접근할 수 있다. (즉, 자바의 정적멤버가 외부에 따로 만들어졌다고 보면 됨)

#### 독립객체 standalone object
- 동반 클래스가 없는 싱글톤 객체
- 독립객체로는 유틸리티 메소드를 모아두는 곳이나 진입점으로 사용할 수 있음


## 스칼라에서 언더스코어 _의 사용 : 모든 or 아무 or 어떤
1. Import : '모든' (자바의 *)
2. 디폴트값으로 초기화 : Int는 0, String은 null로 초기화
3. 고계 함수에서 익명 파라미터
4. 부분 함수에서 익명 파라미터
5. 패턴 매칭 : 타입, 값은 정해지지 않고
6. 제네릭에서 와일드카드 : 제네릭의 <?>
7. 프로퍼티에서 세터


## akka - actor
* **akka**는 스칼라가 강력하고 튼튼한 동시성 애플리케이션을 제공할 수 있도록 하는 API이다. (http://akka.io 참고)
* akka는 actor라는 모델을 기반으로 하는데, **actor**는 서로 아무런 상태 정보를 공유하지 않는 독립적인 소프트웨어 요소이다. 상태를 공유하지 않는 대신, 액터들은 메시지 교환을 통해 서로 의사소통한다.
* akka-actor에 관한 더 자세한 내용은 [여기에] 따로 정리해놓았다.

