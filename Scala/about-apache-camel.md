# Apache Camel
- 참고 블로그: https://miiingo.tistory.com/200

## 개요
- 시스템 통합을 위한 자바 프레임워크
- 엔터프라이즈 통합 패턴을 기반으로 하는 다양한 오픈 소스 통합 프레임워크
- 채널을 흐르는 메시지가 고정된 표준 데이터 타입이 아니어도 된다.
- 카멜이 메시지의 현재 데이터 타입을 추적하고, 확장 가능한 데이터 타입 전환하는 기능을 포함
- 카멜이 메시지를 프로세스의 다음 단계에서 요구하는 데이터 타입으로 전환
- HTTP를 사용하여 HTTP, ActiveMQ와 같은 모든 유형의 전송 또는 메시징 모델과 그 가능 구성 요소 및 데이터 형식 옵션을 직접 처리
- Java 응용 프로그램에 쉽게 포함될 수 있도록 최소한의 종속성을 가진 작은 라이브러리
- 매우 유연하게 조합되어 고도로 독립적인 Java 코드라도 카멜에서 쉽고 빠르게 확장 가능


## 카멜의 개념

#### 메시지(Message)
- 경로로 전송되는 데이터 포함
- 각 메시지에는 고유한 식별자가 있으며 본문, 머리글 및 첨부파일로 구성

#### 익스체인지(Exchange)
- 메시지의 컨테이너
- 메시지가 라우팅 프로세스 중에 consumer에 의해 수신될 때 만들어짐
- 시스템간에 서로 다른 유형의 상호 작용을 허용
- 단방향 메시지 또는 요청-응답 메시지를 정의 가능
- 시스템 간 대화의 상태를 포함하고 있는 홀더 객체
- 구성
    - 속성: key(String)와 value(Object)의 맵 형식
    - 플래그(flag)
    - 메시지 교환 패턴(MEP: Message Exchange Pattern)(InOnly/InOut)
    - 두 개의 메시지(In/Out)
        - 하나의 메시지는 처리 단계에서 사용되는 페이로드뿐만 아니라 key(String)와 value(Object)의 맵으로 표현되는 헤더를 가짐
        - 헤더: 프로세서 간 메시지에 관해 부가적인 정보를 전달하기 위해 사용
        - In 메시지: 항상 프로세서로 들어가는 익스체인지를 나타냄
        - Out 메시지


#### 컨텍스트
- 라우트에 정의된 단계를 따라 익스체인지를 처리하는 엔진
- 카멜 프레임워크의 핵심
- 오래 실행되는(long-running) 객체로 애플리케이션이 살아있는 동안 유지됨
- 초기화와 종료는 주로 애플리케이션의 수행주기에 맞물려있음
- 메시지들은 컴포넌트 기술에 적절한 스레딩 모델을 기반으로 라우트에 뿌려짐
- 그 후의 스레딩은 라우트에 정의된 프로세서들에 의존
- 카멜 컨텍스트는 주로 다음 위치에서 정의
    - 독립 커맨드 기반 애플리케이션의 main() 메소드 내에서 정의.
    - 웹 애플리케이션의 javax.servlet.ServletContextListener의 인스턴스 변수에 정의되어 애플리케이션의 시작과 종료를 함께 함

#### 컴포넌트
- 전송 또는 공통 카멜 인터페이스들 뒤에서 



#### 엔드포인트
- 컴포넌트에 의해 해석되는 주소값
- 컴포넌트가 메시지를 받거나 보내는 디렉토리, 메시지 큐 또는 데이터베이스 테이블 같은 대상 자원을 식별
- 엔드포인트는 URI로 표현되며, 그 속성들은 대응되는 특정 컴포넌트에만 적용됨
- 웹 서비스 URI, 대기열 URI, 파일, 전자 메일 주소 등을 참조 가능
- from() 안에 사용되는 하나의 엔드포인트를 Consumer 엔드포인트라 함
- to() 안에 사용되는 것을 Producer 엔드포인트라 함


#### 표현식
- 메시지를 처리하는 인라인 코드를 라우트 내에 넣는 하나의 방법
- 표현식은 많은 EIP들에 사용되어 메시지 라우팅에 영향을 줌


#### 카멜 아키텍처
- CamelContext는 Camel 런타임 시스템을 나타내며 Route, Component 또는 Endpoint와 같은 다른 개념을 연결
- 그 아래에서 Processor는 Endpoint 간의 라우팅 및 변환을 처리하고 Endpoint는 다른 시스템을 통합


#### 카멜 DSL(Domain Specific Language)
- 카멜의 라우트는 각각의 DSL을 통해 정의
- Java 기반 FluentAPI, Spring 또는 Blueprint XML 구성 파일, Scala DSL을 비롯한 다양한 도메인 별 언어로 라우팅 및 조정규칙 정의 가능




