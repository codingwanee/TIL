# 카프카 브로커 kafka broker
* 참고한 글 https://always-kimkim.tistory.com/entry/kafka101-broker?category=876258

## 카프카 브로커 개념
* 카프카 브로커는 일반적으로 '카프카'라고 불리는 시스템을 말한다.
* 프로듀서와 컨슈머는 별도의 애플리케이션으로 구성되는 반면, 브로커는 카프카 자체라고 볼 수 있기 때문이다.
* 따라서 '카프카를 구성한다' 혹은 '카프카를 통해 메시지를 전달한다'에서 말하는 카프카는 곧 카프카 브로커이다.


## 카프카 브로커 클러스터 kafka cluster
* 카프카 브로커는 한 대 이상의 노드로 클러스터를 구성할 수 있다.
* 현재 카프카에서는 브로커의 여러가지 메타 정보를 저장&관리하는 주키퍼zookeeper가 필수로 함께 쓰여야 한다.


## 주키퍼 zookeeper
* 주키퍼는 아파치 프로젝트 중 하나로, 하둡 에코 시스템을 구성한다.
* 주 역할은 분산 시스템의 메타 정보를 관리하고 필요시에는 분산 시스템의 마스터를 선출한다.


#### 카프카와 주키퍼
* 주키퍼는 카프카에서만 국한된 시스템은 아니지만 현재 카프카에서는 주키퍼가 필수 요소이다.
* 카프카 클러스터를 구성하면 주키퍼에는 카프카 클러스터의 식별정보부터 현재 살아있는 브로커 정보, 권한정보 등이 저장된다.
* 또한 카프카 브로커들 중 컨트롤러 브로커controller broker를 뽑는 역할을 담당한다.
* 주키퍼는 디렉토리 형태로 데이터를 저장, 관리한다. 카프카의 메타 정보 역시 클러스터를 구성할 때 주키퍼 연결 설정(zookeeper.connect)에서 지정된 디렉토리 하위에 저장된다.
* 따라서 동일한 카프카 클러스터는 주키퍼 연결 설정에서 동일한 디렉토리 경로를 가지며, 하나의 주키퍼 클러스터에 여러 카프카 클러스터가 동시에 구성될 수 있다.


#### peer-to-peer 구조
* 카프카 클러스터는 모든 브로커가 클라이언트의 요청을 처리할 수 있는 peer-to-peer 즉 p2p 구조를 가진다.
* 이렇게 p2p 구조가 가능한 것은 client - broker 간에 메타데이터를 전달하는 과정이 있기 때문이다.
* 다만 브로커는 p2p더라도 실제로 메시지를 전달받고 저장하는 단위인 파티션은 리더와 팔로워로 나뉘어 작업을 처리한다.



## 주요 브로커 설정
* 브로커는 여러 환경에 따라 다양한 설정을 할 수 있다.
* 대부분 기본값이 제공되지만, 필수적으로 수동설정 해야 하는 3가지가 있다.
    1. broker.id
    2. log.dirs
    3. zookeeper.connect


#### broker.id
* 같은 카프카 클러스터 내에서 각 브로커를 식별하기 위한 숫자
* 따라서 브로커 별로 각기 다른 숫자를 설정해야 한다.
* 일반적으로 0 또는 1부터 순차적으로 숫자를 부여한다.


#### log.dirs
* 브로커가 프로듀서로부터 받는 메시지들을 저장할 위치 경로
* 기본값은 /tmp/kafka-logs
* 주의할 점은 기본값이 /tmp/ 하위에 지정되기 때문에 OS 설정에 따라 임의로 삭제될 수 있다. 이 때문에 별도의 위치 지정이 반드시 필요한 것이다.


#### zookeeper.connect
* 카프카 클러스터의 메타 정보를 저장할 주키퍼에 관한 호스트 연결정보
* 호스트 연결 정보는 hostname:port로 구성되며, 동일한 주키퍼 클러스터의 여러 노드를 ','로 구분한 문자열로 지정할 수 있다.
    * ex) zookeeper01:2181, zookeeper02:2181
* 주키퍼 내부의 저장 위치를 디렉토리 형식으로 함께 설정할 수도 있다.
    * ex) zookeeper01:2181, zookeeper02:2181/my/path


#### 기타 중요한 설정
* advertised.listeners
    * 클라이언트가 브로커를 바라볼 때의 브로커 호스트 정보.
* auto.create.topics.enable
    * 클라이언트가 특정 토픽으로 요청했을 경우 자동 생성 여부. (기본값 true)
    * 해당 설정이 true일 경우 클라이언트 요청에 따라 토픽이 지속적으로 생성되기 때문에 운영상에 큰 골치가 될 수 있다.
* offsets.topic.replication.factor
    * 오프셋 토픽의 복제 계수. (기본값 3)
    * 개발 환경에서 카프카를 1대로 구성할 경우에는 반드시 이 값을 1로 설정해주지 않으면 충돌이 일어난다.



 ## 브로커 내부 동작 요소
 
 #### 컨트롤러 controller
 * 컨트롤러란?
    * 컨트롤러는 한 클러스터 당 하나의 브로커에 부여되는 역할로, 지휘자와 같은 역할을 한다.
 * 컨트롤러의 역할
    * 컨트롤러는 브로커들의 생존여부(liveness)를 체크한다.
    * 만약 임의의 브로커가 중단되었을 경우 해당 브로커에 있던 리더 파티션을 탈락시키고 다른 팔로워 파티션들 중 하나를 리더로 뽑는다.(leader election)
    * 만약 컨트롤러가 중단되는 경우에는 주키퍼가 이를 감지하여 새로운 컨트롤러를 선출한다.
    * 이 과정은 카프카의 실패 극복에 있어 중요한 역할을 한다.


 #### 메시지 저장과 메시지 파일 관리
 * 카프카 시스템을 만들 때 창시자인 제이크 랩스는 모든 데이터를 로그(log)라고 보았다. 따라서 브로커는 프로듀서로부터 전달되는 메시지를 로그(log) 자료구조 형태로 디스크에 저장한다.
 * 로그 자료구조는 새로운 쓰기 작업이 중간에 삽입되지 않고 오로지 데이터 끝에서만 가능한 append-only 방식이다.
 * 이 특성 때문에 브로커에서는 이미 쓰여진 메시지(로그)의 변경은 불가능하다. 대신 빠른 쓰기 작업이 가능하다는 특징이 있다.


##### 메시지 저장 방식
* 메시지가 브로커에 저장될 때는 메시지 내용과 함께 오프셋 정보가 저장된다.
    * offset : 파티션 내에 위치를 나타내서 메시지를 구분하는 식별자 역할을 한다.
* 브로커에 저장되는 메시지들은 파티션 별로 세그먼트 segment라는 파일로 저장된다.


 #### 제로카피 zero-copy
 * 카프카가 다른 메시징 큐보다 뛰어난 성능을 제공할 수 있는 이유중 하나는 바로 제로카피(zero-copy)를 사용하기 때문이다.
 * 제로카피 기술은 브로커가 세그먼트 파일로부터 메시지를 읽고 이것을 네트워크로 전달하는 과정에서 문맥교환(context switch)이 없도록 하는 기술이다.
 * 단, 메시지 암호화(SSL)을 설정한 경우에는 메시지 암,복호화를 위해 어쩔 수 없이 문맥교환이 발생하므로 제로카피 기술을 사용할 수 없다.